{"version":3,"sources":["webpack://ScreenMap/webpack/universalModuleDefinition","webpack://ScreenMap/webpack/bootstrap","webpack://ScreenMap/./src/SMScreen.js","webpack://ScreenMap/./src/ScreenMap.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClQA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsC;AACtC;AACA;AACA;AACO;AACP;AACA,mCAAmC;AACnC,mCAAmC;AACnC,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAQ;AAC1C;AACA;AACA","file":"ScreenMap.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ScreenMap\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ScreenMap\"] = factory();\n\telse\n\t\troot[\"ScreenMap\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/ScreenMap.js\");\n","/*----------------------------------------------------------------------------------------------------------\r\n::“Copyright 2018 Clayton Burnett”\r\n::This program is distributed under the terms of the GNU General Public License\r\n------------------------------------------------------------------------------------------------------------*/\r\n/**\r\n * @fileOverview\r\n *\r\n * This file contains the main abstraction for a single screen\r\n *\r\n * @author Clayton Burnett <the82professional@hotmail.com>\r\n */\r\n/**\r\n * ###############################################################################################################\r\n *                                              SMScreen\r\n */\r\n/**\r\n * @class\r\n * Class modeling a canvas screen\r\n *\r\n * @description\r\n * A screen is modeled as a pair of blitting canvas elements\r\n **/\r\n/**\r\n* @constructor\r\n*/\r\nexport class SMScreen {\r\n    constructor(Canvas, IniRes, ID) {\r\n        this.Canvas = Canvas;\r\n        this.IniRes = IniRes;\r\n        this.ID = ID;\r\n        /**\r\n        * Function to flip the displayed screens by swapping video buffer\r\n        */\r\n        this.Blit = function () {\r\n            if (this.bctx && this.ctx) {\r\n                var offscreen_data = this.bctx.getImageData(0, 0, this.XResolution, this.YResolution);\r\n                this.ctx.putImageData(offscreen_data, 0, 0);\r\n            }\r\n        };\r\n        //Default Constructor\r\n        this.Res = IniRes || new Array(100, 100);\r\n        this.DOMArray = new Array();\r\n        this.ID = ID || 0;\r\n        this.RenderFlag = true;\r\n        this.RenderRate = 0; //Used internally to calculate refresh\r\n        this.BackgroundImages = new Array(); //The Current array of background Images\r\n        if (Canvas) {\r\n            for (let i of Canvas) {\r\n                this.ctx = i[0].getContext('2d');\r\n                this.bctx = i[1].getContext('2d');\r\n            }\r\n        }\r\n    }\r\n    //-------------------------------------------------------------SET METHODS---------------------------\r\n    /**\r\n    * Set the element screen resolution\r\n    * @param {Integer} Count Sets the current render count\r\n    */\r\n    set RenderSpeed(Count) {\r\n        if (Count) {\r\n            this.RenderRate = Count;\r\n        }\r\n        else {\r\n            console.log(\"Cannot set the render rate to: \" + Count);\r\n        }\r\n    }\r\n    /**\r\n    * Set the text width\r\n    * @param {Integer} Width Sets the text width to apply to created text elements\r\n    */\r\n    set SetTextWidth(Width) {\r\n        if (Width) {\r\n            this.TextWidth = Width;\r\n        }\r\n        else {\r\n            console.log(\"Text width not defined in SetTextWidth(Try using an integer value)\");\r\n        }\r\n    }\r\n    /**\r\n    * Set the line height\r\n    * @param {Integer} Height Sets the default line height to be applied to text elements\r\n    */\r\n    set SetLineHeight(Height) {\r\n        if (Height) {\r\n            this.LineHeight = Height;\r\n        }\r\n        else {\r\n            console.log(\"Line height not defined in SetLineHeight(Try using an integer value)\");\r\n        }\r\n    }\r\n    /**\r\n    * Set the element screen resolution\r\n    * @param {Integer[]} Resolution Sets the resolution of the canvas element\r\n    */\r\n    set Resolution(Resolution) {\r\n        if (Resolution.length == 2) {\r\n            this.Res = Resolution;\r\n        }\r\n        else {\r\n            console.log(\"Cannot set screen\" + this.ID + \"to resolution\" + Resolution + \"requires x/y integer array\");\r\n        }\r\n    }\r\n    /**\r\n    * Set Timeout\r\n    * @param {Array[]} DOMArray Updates the screen DOM\r\n    */\r\n    set DOM(DOMArray) {\r\n        this.DOMArray = DOMArray;\r\n    }\r\n    /**\r\n    * Sets whether to render this screen during the screenmap render cycle\r\n    * @param {Boolean} Flag A boolean value indicating either true(Render) or false(do not render)\r\n    */\r\n    set Render(Flag) {\r\n        if (Flag) {\r\n            this.RenderFlag = Flag;\r\n        }\r\n        else {\r\n            console.log(\"Render must be either true or false\");\r\n        }\r\n    }\r\n    //----------------------------------------------------------GET METHODS-------------------------------\r\n    /**\r\n    * Gets the unique screen ID\r\n    * @returns {Number} The unique screen ID\r\n    */\r\n    get GetID() {\r\n        return (Number(this.ID));\r\n    }\r\n    /**\r\n    * Gets the current render count\r\n    * @returns {Number} The current render count\r\n    */\r\n    get GetRenderSpeed() {\r\n        return (Number(this.RenderRate));\r\n    }\r\n    /**\r\n    * Gets the current render count\r\n    * @returns {Boolean} The current render state(true:on, false:off)\r\n    */\r\n    get GetRenderState() {\r\n        return (Boolean(this.RenderFlag));\r\n    }\r\n    //-----------------------------------------------------------PUBLIC INTERFACE---------------------------------\r\n    /**\r\n    * Function to add an item to the render DOM\r\n    * @param {number[]} Origin Origin x/y of the upper left corner of the drawable\r\n    * @param {number[]} Dimensions where to draw the sprite in an x/y number array\r\n    * @param {string} Image Name of the sprite to use\r\n    * @param {string} Type type of the sprite to use(Sprite|Text|Background)\r\n    */\r\n    Draw(Origin, Dimensions, Image, Type, Font, FillStyle, Text) {\r\n        //this.bctx.drawImage(Sprite, xcord, ycord, width, height);\r\n        let Item;\r\n        Item.dimensions = Dimensions;\r\n        Item.fillstyle = FillStyle;\r\n        Item.font = Font;\r\n        Item.image = Image;\r\n        Item.origin = Origin;\r\n        Item.type = Type;\r\n        Item.text = Text;\r\n        this.DOMArray.push(Item);\r\n    }\r\n    /**\r\n    * Function to render the map to the background canvas and blit\r\n    */\r\n    RenderDOM() {\r\n        //Render Backgrounds First\r\n        for (let i of this.DOMArray) {\r\n            if (i.type == \"Background\") {\r\n                //0=Image 1=Origin 2=Dimensions 3=Type\r\n                this.bctx.drawImage(i.image, i.origin[0], i.origin[1], i.dimensions[0], i.dimensions[1]);\r\n            }\r\n        }\r\n        //Render Sprites Next\r\n        for (let i of this.DOMArray) {\r\n            if (i[3] == \"Sprite\") {\r\n                //0=Image 1=Origin 2=Dimensions 3=Type\r\n                this.bctx.drawImage(i.image, i.origin[0], i.origin[1], i.dimensions[0], i.dimensions[1]);\r\n            }\r\n        }\r\n        //Render Text Last\r\n        for (let i of this.DOMArray) {\r\n            if (i[3] == \"Text\") {\r\n                this.bctx.fillStyle = i.fillstyle;\r\n                this.bctx.font = i.font;\r\n                this.ctx.fillStyle = i.fillstyle;\r\n                this.ctx.font = i.font;\r\n                this.WrapText(this.bctx, i.text, i.origin[0], i.origin[1], this.TextWidth, this.LineHeight);\r\n            }\r\n        }\r\n        //Refresh the screen\r\n        this.Blit();\r\n    }\r\n    //-----------------------------------------------------------INTERNAL METHODS----------------------------------   \r\n    /**\r\n    * Function to resize the canvas and zoom elements to fit the window maintains aspect ratio\r\n    * @param {Array} PageDimensions Array of XY corresponding to the pages native pixel dimensions\r\n    * @param {Array} WindowDimensions Array of XY corresponding to the current window dimensions\r\n    */\r\n    ScaleCanvas(PageDimensions, WindowDimensions) {\r\n        //------------------------------------------------------FULL SCREEN MODE ONLY SO FAR-------------------------\t\r\n        //Save the canvas before performing transformation\r\n        this.ctx.save();\r\n        this.bctx.save();\r\n        //if the upper left is 0,0\r\n        var ratiox = (WindowDimensions[0] * 100) / PageDimensions[0]; //WindowDimensions[0] - PageDimensions[0];\r\n        var ratioy = (WindowDimensions[1] * 100) / PageDimensions[1];\r\n        ratioy = +ratioy.toFixed(2);\r\n        ratiox = +ratiox.toFixed(2);\r\n        ratioy = ratioy / 100;\r\n        ratiox = 75.57 / 100;\r\n        //if were not scaled correctly\t\r\n        if (ratiox != 100 || ratioy != 100) {\r\n            this.ctx.scale(.50, .50);\r\n            this.bctx.scale(.50, .50);\r\n        }\r\n        this.ctx.restore();\r\n        this.bctx.restore();\r\n        //--------------Implement a write text to screen function that can dynamically change the font position or size\r\n    }\r\n    /**\r\n    * Clears the current screen (not needed with blitting)\r\n    */\r\n    Clear() {\r\n        //--------------------------------------!!WARNING DEBUG MODE-------------------------------------------------------\r\n        //Clear does not properly clear the defined resolution using the single command below\r\n        //this.bctx.clearRect(0, 0, this.XResolution, this.YResolution);\r\n        this.bctx.clearRect(0, 0, 3000, 3000);\r\n    }\r\n    /**\r\n    * Function to wrap the loaded text\r\n    * @param {CanvasContext} context the current Canvas context to display to\r\n    * @param {String} text The text to display within the DOM element\r\n    * @param {Integer} x The starting x position in pixels\r\n    * @param {Integer} y The starting y position in pixels\r\n    * @param {Integer} maxWidth The maximum width to use before wrap\r\n    * @param {Integer} lineHeight The height of the display text\r\n    */\r\n    WrapText(context, text, x, y, maxWidth, lineHeight) {\r\n        var words = text.split(' ');\r\n        var line = '';\r\n        for (var n = 0; n < words.length; n++) {\r\n            var testLine = line + words[n] + ' ';\r\n            var metrics = context.measureText(testLine);\r\n            var testWidth = metrics.width;\r\n            if (testWidth > maxWidth && n > 0) {\r\n                context.fillText(line, x, y);\r\n                line = words[n] + ' ';\r\n                y += lineHeight;\r\n            }\r\n            else {\r\n                line = testLine;\r\n            }\r\n        }\r\n        context.textAlign = \"start\";\r\n        context.fillText(line, x, y);\r\n    }\r\n}\r\n","/*----------------------------------------------------------------------------------------------------------\r\n::“Copyright 2018 Clayton Burnett”\r\n::This program is distributed under the terms of the GNU General Public License\r\n------------------------------------------------------------------------------------------------------------*/\r\n/**\r\n * @fileOverview\r\n *\r\n * This file contains the implementation for the Canvas controller\r\n *\r\n * @author Clayton Burnett <the82professional@hotmail.com>\r\n */\r\n/**\r\n * ###############################################################################################################\r\n *                                              ScreenMap\r\n */\r\n/**\r\n * @class\r\n * Class modeling a Multi-Canvas controller\r\n *\r\n * @description\r\n * This is the canvas manager. When passing in canvas DOM elements pass them in the order: front1, back1, front2, back2 etc.\r\n * The rear rear canvas element will be written to and then \"blitted\" to the front canvas.\r\n **/\r\nimport { SMScreen } from './SMScreen';\r\n/**\r\n* @constructor\r\n*/\r\nexport class ScreenMap {\r\n    constructor(CVChannels) {\r\n        this.GlobalXResolution = 0; //Screen resolution X value in integer format\r\n        this.GlobalYResolution = 0; //Screen resolution Y value in integer format\r\n        this.ZoomLevel = 1; //Current screen magnification level \r\n        this.WindowHeight = window.innerHeight;\r\n        this.WindowWidth = window.innerWidth;\r\n        this.Channels = CVChannels;\r\n        this.Screens = [];\r\n        this.GlobalRefreshLimit = 60;\r\n        this.CycleCount = 0;\r\n        //Run on init function\r\n        this.Init();\r\n    }\r\n    //----------------------------------------------SET METHODS--------------------------------------------------\r\n    /**\r\n    * Sets the default global canvas resolution for all managed canvases\r\n    * @param {Integer[]} Pair An instance of a x[0] and y[1] integer array indicating a resolution\r\n    */\r\n    set SetGlobalResolution(Pair) {\r\n        if (Pair && Pair.length > 1) {\r\n            this.GlobalXResolution = Pair[0];\r\n            this.GlobalYResolution = Pair[1];\r\n        }\r\n    }\r\n    //----------------------------------------------GET METHODS(NONE)-------------------------------------------------\r\n    //----------------------------------------------PUBLIC INTERFACE--------------------------------------------------\r\n    /**\r\n    * Internal function that is run each render cycle\r\n    */\r\n    RenderCycle() {\r\n        if (this.CycleCount < this.GlobalRefreshLimit) {\r\n            this.CycleCount++; //Increment the cycle counter\r\n            //Run screen updates\r\n            for (let i of this.Screens) {\r\n                if (i.GetRenderSpeed <= this.CycleCount && i.GetRenderState == true) {\r\n                    i.RenderDOM();\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            //Reset the cycle counter\r\n            this.CycleCount = 0;\r\n        }\r\n    }\r\n    //----------------------------------------------PRIVATE MEMBER FUNCTIONS------------------------------------------\r\n    /**\r\n    * private ScreenMap initialization function, does not take parameters\r\n    */\r\n    Init() {\r\n        //Create Screen objects for each pair\r\n        let oddeven = 0;\r\n        let ctxArray = [];\r\n        let bctxArray = [];\r\n        //Split up the channels\r\n        for (let i of this.Channels) {\r\n            if (oddeven == 0) {\r\n                ctxArray.push(i);\r\n                oddeven = 1;\r\n            }\r\n            else {\r\n                bctxArray.push(i);\r\n                oddeven = 0;\r\n            }\r\n        }\r\n        for (let i in ctxArray) {\r\n            this.Screens.push(new SMScreen([ctxArray[i], bctxArray[i]], [100, 100], Number(i)));\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""}